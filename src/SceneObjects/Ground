import * as THREE from "three";

export class Ground{

    groundModel;

    static async CreateGround(goundShader) {

        const newGround = new Ground();
        newGround.groundModel = new THREE.Group();

        //Ground material is a modification of the existing THREE.MeshPhongMaterial rather than one from scratch
        var groundBaseGeometry = new THREE.PlaneBufferGeometry(canvas.width, canvas.width, resolution, resolution);
        groundBaseGeometry.lookAt(new THREE.Vector3(0,1,0));
        groundBaseGeometry.verticesNeedUpdate = true;

        var groundGeometry = new THREE.PlaneBufferGeometry(canvas.width, canvas.width, resolution, resolution);
        groundGeometry.setAttribute('basePosition', groundBaseGeometry.getAttribute("position"));
        groundGeometry.lookAt(new THREE.Vector3(0,1,0));
        groundGeometry.verticesNeedUpdate = true;
        var groundMaterial = new THREE.MeshPhongMaterial({color: 0x000900});

        var sharedPrefix = `
uniform sampler2D noiseTexture;
float getYPosition(vec2 p){
	return 8.0*(2.0*texture2D(noiseTexture, p/800.0).r - 1.0);
}
`;

        var groundVertexPrefix = sharedPrefix + ` 
attribute vec3 basePosition;
uniform float delta;
uniform float posX;
uniform float posZ;
uniform float radius;
uniform float width;

float placeOnSphere(vec3 v){
  float theta = acos(v.z/radius);
  float phi = acos(v.x/(radius * sin(theta)));
  float sV = radius * sin(theta) * sin(phi);
  //If undefined, set to default value
  if(sV != sV){
    sV = v.y;
  }
  return sV;
}

//Get the position of the ground from the [x,z] coordinates, the sphere and the noise height field
vec3 getPosition(vec3 pos, float epsX, float epsZ){
  vec3 temp;
  temp.x = pos.x + epsX;
  temp.z = pos.z + epsZ;
  temp.y = max(0.0, placeOnSphere(temp)) - radius;
  temp.y += getYPosition(vec2(basePosition.x+epsX+delta*floor(posX), basePosition.z+epsZ+delta*floor(posZ)));
  return temp;
}

//Find the normal at pos as the cross product of the central-differences in x and z directions
vec3 getNormal(vec3 pos){
  float eps = 1e-1;

  vec3 tempP = getPosition(pos, eps, 0.0);
  vec3 tempN = getPosition(pos, -eps, 0.0);
  
  vec3 slopeX = tempP - tempN;

  tempP = getPosition(pos, 0.0, eps);
  tempN = getPosition(pos, 0.0, -eps);

  vec3 slopeZ = tempP - tempN;

  vec3 norm = normalize(cross(slopeZ, slopeX));
  return norm;
}
`;

        groundMaterial.onBeforeCompile = function ( shader ) {
            shader.uniforms.delta = { value: delta };
            shader.uniforms.posX = { value: pos.x };
            shader.uniforms.posZ = { value: pos.y };
            shader.uniforms.radius = { value: radius };
            shader.uniforms.width = { value: canvas.width };
            shader.uniforms.noiseTexture = { value: noiseTexture };
            shader.vertexShader = groundVertexPrefix + shader.vertexShader;
            shader.vertexShader = shader.vertexShader.replace(
                '#include <beginnormal_vertex>',
                `//https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e
			vec3 pos = vec3(0);
      pos.x = basePosition.x - mod(mod((delta*posX),delta) + delta, delta);
      pos.z = basePosition.z - mod(mod((delta*posZ),delta) + delta, delta);
      pos.y = max(0.0, placeOnSphere(pos)) - radius;
      pos.y += getYPosition(vec2(basePosition.x+delta*floor(posX), basePosition.z+delta*floor(posZ)));
      vec3 objectNormal = getNormal(pos);
#ifdef USE_TANGENT
      vec3 objectTangent = vec3( tangent.xyz );
#endif`
            );
            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `vec3 transformed = vec3(pos);`
            );
            groundShader = shader;
        };

        var ground = new THREE.Mesh(groundGeometry, groundMaterial);

        ground.position.y = .5
        ground.scale.set(.06, .06, .06);

        ground.geometry.computeVertexNormals();

        return newGround;
    }

}